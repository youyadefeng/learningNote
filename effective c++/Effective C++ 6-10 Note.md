# Effective C++ 6-10 Note

## 条款06：若不想使用编译器自动生成的函数，就明确拒绝

在老版的C++中，将不想自动生成的函数声明为private并且不定义

![image-20210312091616727](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312091616727.png)

在当前版本的C++中，可以使用delete修饰符进行修饰



## 条款07：为多态基类声明virtual析构函数

### 带多态性质的基类应该声明一个虚析构函数，如果类带有任何虚函数，它就应该有一个虚析构函数

当出现基类指针或引用指向派生类对象时，如果析构函数不为虚函数，那么调用的就是静态对象的析构函数，也就是基类的析构函数，这会导致派生类的派生部分没有删除

### 如果类的设计目的不是作为基类使用，或不是为了具备多态性，就不应该声明virtual的使用

为了实现virtual函数，对象必须携带某些信息，主要用来在运行期决定哪一个virtual函数应该被调用。而这额外的信息是具有一定开销的。

## 条款08：别让异常逃离析构函数

### 析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序

如果析构函数抛出异常，就会导致对象不能完全析构而内存泄漏。

析构函数出现异常时结束程序的写法：

![image-20210312092859908](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312092859908.png)

析构函数出现异常时吞下异常的写法：

![image-20210312092951038](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312092951038.png)

一般来说吞下异常不是一种好的解决方式，因为这样会忽略某些已经发生的错误。

### 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数执行该操作

重新设计类，将close的操作抛给用户执行。当然，在析构的时候也要检查是否close。如果没close还是要像之前一样帮用户处理。如果出现异常，责任会落到“用户忘记close”上，而不是“错误的类设计”身上

![image-20210312093255148](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312093255148.png)

## 条款09：绝不在构造或析构过程中调用virtual函数

### 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类

![image-20210312093735156](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312093735156.png)

![image-20210312093757501](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312093757501.png)

BuyTransaction的构造函数会被调用，而它基类Transaction的构造函数会更先一步执行。在基类的构造函数中调用了一个虚构函数logTransaction，此时正处于基类构造阶段，派生类成员还没有初始化，编译器会将此阶段的对象识别为Tansaction基类，所以该虚构函数会调用基类版本的函数，而不是调用派生类版本。“在基类构造期间，虚函数不是虚函数”

同样的道理也适用于析构函数

### 可以适用“令派生类传递必要的信息给基类构造函数，然后利用该信息调用非虚构版本的函数”的方法替代弥补虚构函数的多态性

## 条款10：令 operator= 返回一个 reference to *this

这只是个协议，并无强制性，如果不遵循它，代码一样可以通过编译。但是这份协议被所有内置类型和标准程序库提供的类型或即将提供的类型共同遵守。因此除非你有一个标新立异的好理由，不然还是随众吧

这个协议**不仅适用于标准赋值形式，也适用于所有赋值相关运算**
