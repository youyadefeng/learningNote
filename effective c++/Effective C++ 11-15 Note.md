# Effective C++ 11-15 Note

## 条款11：在operator=中处理“自我赋值”

### 确保当对象自我赋值时，拷贝赋值函数有良好的行为。其中的技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap

比较“来源对象”和“目标对象”：

![image-20210312095803082](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312095803082.png)

复制：

![image-20210312095932187](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312095932187.png)

pb在new操作之后已经指向了一块新的内存地址，所以delete原来地址也是没问题的。

copy-and-swap：

![image-20210312100137094](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312100137094.png)

![image-20210312100147959](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210312100147959.png)

第一个版本为引用版本，需要利用拷贝构造函数构造一个临时对象，然后让源数据与该临时对象进行交换。

第二个版本为值传递版本，此时传入的参数是拷贝而来的，所以直接让源数据与参数进行交换。

### 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确

## 条款12：复制对象时勿忘其每个成分

### copoying函数应该确保复制“对象内的所有成员”及“所有base class”对象

如果你为class添加一个成员变量，你必须同时修改**copying函数**以及**相应的赋值函数**。

你应该让派生类的copying函数调用相应的基类函数

### 不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放到第三个函数中，并由两个copying函数共同调用

## 条款13：以对象管理资源

### 为防止资源泄漏，请使用RAII对象（资源取得时间便是初始化时机（Resource Acquision Is Initials）），它们在构造函数中获得资源并在析构函数中释放资源

获得资源后立即放进管理对象

管理对象运用析构函数确保资源被释放

### 两个常用RAII对象分别是tr1::shared_ptr和auto_ptr。前者通常是最佳选择



## 条款14：在资源管理器中小心copying行为

### 复制RAII对象必须一并复制它所管理的资源

### 普遍而常见的RAII class copying行为是：禁止复制、对底层资源使用“引用计数”、复制底层资源、转移底部资源的拥有权

对底层资源使用“引用计数”：需要在类中使用shared_ptr成员变量。可以自定义“删除器”，在引用计数为0的时候被自动调用

复制底层资源：也就是所谓的深拷贝

转移底部资源的拥有权：行为和unique_ptr差不多



## 条款15：在资源管理器中提供对原始资源的访问

### APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的方法。

### 对原始资源的访问可能经有显式转换或隐式转换，一般而言显式转换比较安全

显式转换指的是用户自己知道需要一个原始资源，并且调用某些函数得到。一个好的例子是shared_ptr的get函数







