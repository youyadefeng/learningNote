# 《C++标准库》第5章 通用工具

## pair和tuple

### 便捷函数make_pair()

Template函数make_pair()，能够让我们无须写出类型就能生成一个pair对象。

![image-20210330085507670](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330085507670.png)

![image-20210330085524764](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330085524764.png)

make_pair函数的自动推断有时候可能并非用户所想，一个表达式用户明白的指出类型时，产生出来的pair将有绝对明确的类型

![image-20210330085744504](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330085744504.png)

### Tuple（不定数的值组）

![image-20210330085851771](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330085851771.png)

#### Tuple中的每个类型由默认构造函数初始化，基础类型都会被初始化为0

#### get函数所需要的index必须在编译期已知，运行期再传入一个值是不被允许的：

![image-20210330090106740](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330090106740.png)

#### 便捷函数ref和cref应用于Tuple

![image-20210330090448572](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330090448572.png)

![image-20210330090400414](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330090400414.png)

## 智能指针

### shared_ptr

#### 显式构造函数不能使用赋值符

![image-20210330090644907](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330090644907.png)

![image-20210330090725479](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330090725479.png)

#### 对付Array

shared_ptr提供的默认删除器调用的是delete，而不是delete[]。这意味着如果我们想要使用指针指针指向一个数组，我们需要自定义delete[]删除器

![image-20210330091043201](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330091043201.png)

#### 不要误用shared_ptr

![image-20210330091233624](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330091233624.png)

第二个智能指针不要传底层指针作为参数，而是得传第一个智能指针作为参数

#### reset函数

![image-20210330091354098](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330091354098.png)

### Unique_ptr

#### 不可以对unique_ptr执行copy和assign

![image-20210330091538084](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330091538084.png)

![image-20210330091554729](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330091554729.png)

注意第三个语句，可以传一个右值unique_ptr作为构造函数的参数

#### 赋予新值必须是unique_ptr

![image-20210330091746076](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330091746076.png)

#### unique_ptr转移的源头和去处

函数端：

![image-20210330091904381](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330091904381.png)

unique_ptr作为函数实参，传参要使用move语义

供应端：

![image-20210330092014468](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330092014468.png)

函数返回一个右值指针

#### 习惯将unique_ptr当作成员

![image-20210330092130351](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330092130351.png)

数据成员包含unique_ptr，在构造函数传入对应的数据时对ptr进行初始化。这样就可以预防因构造函数产生异常而导致的资源泄漏。这样处理之后甚至不用写构造函数，因为智能指针在对象销毁时会自动释放资源。

但此时我们应该写出copy构造函数和赋值操作符。如果没有自行提供，编译器将会默认生成move语义版本

#### 对付array，偏特化

![image-20210330092701847](C:\Users\94375\AppData\Roaming\Typora\typora-user-images\image-20210330092701847.png)

该class不接受一个派生类型的array作为初值，所以在array身上起不了多态作用

### 智能指针结语

shared和weak指针内部都需要额外的辅助对象，以内部pointer指向（引用计数器等）。这会导致额外的内存开销，无法进行许多优化动作。

Unique_ptr 则完全不需要这样的额外开销，使用它和使用原生指针效率几乎相同

## 数值的极值

### class numerical_limit<>

该模板类中含有内置数值类型的很多信息，它们以类的静态数据和静态函数的形式存在，大多数成员被声明为constexpr，它们在编译期就可以进行访问

![image-20210331104539663](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331104539663.png)

![image-20210331104547515](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331104547515.png)

用例：

![image-20210331104738552](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331104738552.png)

## Type Trait和Type Utility

### 基本用法举例

type Trait是用来处理**类型属性**的办法。它是个template，可在编译期根据一个或多个template实参产出一个type或value

![image-20210331105049919](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331105049919.png)

上述例子就用到了type Trait来判断传入类型是否为指针，将其改为重载函数的形式：

![image-20210331105208438](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331105208438.png)

![image-20210331105217305](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331105217305.png)

在调用重载函数时使用type trait，根据传入的是std::true_type还是std::false_type来判断是否为指针。

### 处理共通类型

当两个不同类型的值进行运算时，该返回什么共通类型呢？

![image-20210331105721506](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331105721506.png)

![image-20210331105744111](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331105744111.png)

### 类型判断式

如果该类型满足特定的性质，则它的内部静态成员变量value的值为std::true_type，否则为std::false_type。

![image-20210331105949376](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331105949376.png)

![image-20210331110003830](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110003830.png)

用例：

![image-20210331110118597](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110118597.png)

### 用以校验类型关系的Trait

检查类型之间的关系，检查class提供了哪一种构造函数和哪一种赋值操作

![image-20210331110222456](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110222456.png)

例子：

![image-20210331110336330](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110336330.png)

### 类型修饰符

使用下列方法可以对类型进行改动，比如原来该类型不为const，使用方法后可以变为const。

但要注意的是这里针对的是类型，而不是实际的对象

![image-20210331110509332](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110509332.png)

例子：

![image-20210331110518572](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110518572.png)

### 其他Type Trait

用来查询特殊属性、检查类型关系或提供更为复杂的类型变换

![image-20210331110722146](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110722146.png)

例子：
![image-20210331110744145](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331110744145.png)

### Reference Wrapper（外覆器）

![image-20210331111008682](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331111008682.png)

### Function Type Wrapper（外覆器）

class std::function<>，声明于<functional>, 提供多态外覆器。可以借用这个将函数、函数指针、lambda表达式、可调用类这些可调用对象统一类型。

![image-20210331111336008](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331111336008.png)

## 辅助函数

### 最值函数

![image-20210331115029928](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331115029928.png)

minmax<>返回一个pair<>，first是最小值，second是最大值

### 交换 swap

![image-20210331115524943](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331115524943.png)

### 增补的“比较操作符”

![image-20210331115618864](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第5章 通用工具\image-20210331115618864.png)