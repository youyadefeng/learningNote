# 《C++标准库》第6章 标准模板库

# STL组件

STL组件中最关键的三大组件：容器、迭代器、算法

![image-20210401112210316](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401112210316.png)

![image-20210401112224110](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401112224110.png)

![image-20210401112245682](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401112245682.png)

# 容器

容器可分为三大类：序列式容器、关联式容器、无序容器

![image-20210401112418719](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401112418719.png)

![image-20210401112428857](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401112428857.png)

序列式容器的有序指的是插入位置上的有序，先插入的排在前面，后插入的排在后面

关联式容器的有序指的是元素顺序上的有序，根据元素值大小进行排序

## 序列式容器

array、vector、deque、list

### Vector

![image-20210401112727862](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401112727862.png)

也可以使用insert和迭代器实现在首部和中部插入元素，但效率较低

### Deque

![image-20210401112859576](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401112859576.png)

可以向两端发展意味着首尾插入效率较高

一般而言，STL容器只提供具备良好时间效率的成员函数，所谓“良好”通常意味着其复杂度为常量或对数，以免程序员调用性能很差的函数

### Array

![image-20210401113113380](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113113380.png)

在创建对象时需要在模板类型参数中提供元素个数

### List

![image-20210401113251556](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113251556.png)

List在任何位置上插入和删除的效率都很好

例子：

![image-20210401113346239](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113346239.png)

### Forward_list

![image-20210401113444952](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113444952.png)

![image-20210401113632980](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113632980.png)

例子：

![image-20210401113708984](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113708984.png)

## 关联式容器

![image-20210401113803775](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113803775.png)

![image-20210401113956865](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401113956865.png)

### Set 和 MultiSet 例子

![image-20210401114116765](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114116765.png)

### Map 和 Multimap 例子

![image-20210401114202723](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114202723.png)

map里面存储的对象其实是pair\<const key, value>类型，Key之所以必须是常量，因为其内容如果被改动，会破坏元素的次序，而元素次序是由容器自动排序的。

## 无序容器

![image-20210401114430802](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114430802.png)

使用无序容器唯一的目标是查看某个特定元素是否位于容器内，当你打算从无序容器中查找一个带某特定值的元素，其速度甚至可能快过关联式容器

![image-20210401114507719](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114507719.png)

![image-20210401114636078](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114636078.png)

可以把unordered set看作一种特殊的map，其value值等同于key

### unordered set 和 unordered multiset 例子

![image-20210401114815990](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114815990.png)

unordered multyset，两个相同元素先后插入set中时，先插入的那个元素会被安置在后插入那个元素之前，它们的先后相对顺序是不变的。

### unordered map 和 unordered multimap

![image-20210401114900446](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114900446.png)

![image-20210401114909138](https://yydf-1305206966.cos.ap-nanjing.myqcloud.com/image-20210401114909138.png)

### unordered容器的hash函数

系统为内置类型和string准备了默认的hash函数，至于其他类型，我们必须提供自己的hash函数

### 关联式数组

map和unorderedmap可以视作一个关联式数组，它提供了下标操作符，以key作为索引，取得value

![image-20210402085228048](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402085228048.png)

![image-20210402085249396](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402085249396.png)

注意这里会使用默认构造函数或初始化为0

## 容器适配器

![image-20210402085432106](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402085432106.png)

# 迭代器

## begin和end半开区间的好处

![image-20210402090509954](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402090509954.png)

1、为“遍历元素时的loop结束时机”提供一个简单的判断依据。只要尚未到达end，loop就可以继续进行

2、不必对空区间采取特殊处理手法。空区间的begin就等于end

## map中的元素

使用迭代器遍历map中元素时，取得的其实是pair类型的，first指向key，second指向value

## 前置运算符和后置运算符

没有特殊需求的话，最好使用前置运算符。因为后置运算符需要消耗额外的空间存储旧值，然后再进行运算。在我们不需要这个旧值的情况下使用前置运算符可以节省空间，提高效率。

![image-20210402091110454](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402091110454.png)

## 范围for循环的精确行为

![image-20210402091207729](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402091207729.png)

## 关联式及无序容器的更多实例

### 允许使用初始值列表进行插入操作

![image-20210402091339570](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402091339570.png)

### Set内部存储元素的机制

![image-20210402091410126](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402091410126.png)

任何节点的左子树都比自身小，右子树都比自身大

### Set容器遍历顺序

![image-20210402091500078](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402091500078.png)

按照左子树、自身、右子树的顺序对存储组成的二叉树进行遍历

### unordered multiset的遍历顺序

由于容器是无序的，顺序取决于hash table和hash函数。每加入一个元素都有可能改变现有元素的顺序。

它唯一可以保证的是，内容相同的元素会相邻

![image-20210402091842704](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402091842704.png)

## 迭代器的种类

![image-20210402092006469](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402092006469.png)

注意，只有随机访问迭代器才能使用“四则运算符”和“<判断符”。

而“!=判断符”则适用于所有迭代器

![image-20210402092223556](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402092223556.png)

### 尽可能写出与容器类型无关的泛型算法

![image-20210402092317798](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402092317798.png)

上面的版本更好，适用于所有类型的迭代器。而下面版本则只适用于随机访问迭代器

# 算法

算法并非容器类的成员函数，而是一种搭配迭代器使用的全局函数。

在面向对象编程的概念中，数据和操作合为一体。而在STL中则被明确的划分开，通过特定的接口彼此互动

需要包括头文件\<algorithm>

### min_element、max_element

![image-20210402092726317](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402092726317.png)

![image-20210402092739699](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402092739699.png)

求出范围内的最小值或最大值的位置，**返回指向该值的迭代器**

### find

![image-20210402092841869](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402092841869.png)

在指定范围内寻找特定值，返回指向该值的迭代器。如果范围内不存在指定值，则返回第二实参所指示的区间末端。

在算法中要求传入的迭代器指示的区间全都是左闭右开的，最右边那个位置是取不到的。如果返回的是最右边位置的迭代器，说明算法遍历完了整个区间也没有停下，也就说明这个区间没有满足条件的值

### reverse

将区间内的元素反转放置

![image-20210402093214587](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402093214587.png)

## 区间

调用者必须确保经由两实参定义出来的区间是有效的，所谓有效就是，从起点出发，逐一前进，能够到达终点

如果使用的是随机访问迭代器，可以使用<判断符来判断[left,right)是否是一个有效区间。（left <= right）

如果是其他迭代器，使用!=判断符不能确保区间的有效。因为left可能>right

### 处理多重区间

有数个算法可以处理多重区间。通常你必须设定第一个区间的起点和终点。至于其他区间，只需设定起点即可，终点通常可由第一个区间元素的数量推断出来。

这使我们收获一个重要心得：如果某个算法用来处理多重区间，那么当你调用它时，务必确保第二（以及其他）区间所拥有的元素个数至少和第一区间内的元素个数相同

![image-20210402104203387](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402104203387.png)

####　equal

![image-20210402104318894](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402104318894.png)

比较两个区间内的所有元素是否相同。要比较的元素个数由第一区间指出

#### copy

![image-20210402104449431](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402104449431.png)

将第一区间的元素全部拷贝至目标区间。

上图中的例子将会报错，拷贝算法执行的是覆写而不是插入，覆写意味着将原来的内容覆盖，需要原来就存在空间。这里的coll2原来的空间大小为0，无法执行覆写。

#### unique_copy

![image-20210402110736236](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402110736236.png)

将第一区间的元素复制到目标区间，期间会消除相邻的重复值。使用前需要先进行排序，保证相同值相邻

### 预防处理多重区间时可能会发生的错误

处理多重区间时发生错误是因为目标区间没有足够的空间存放元素。为了预防这种错误，可以使用两种方法：

1、确认目标区间内拥有足够空间（初始化时指定大小，使用前调整大小）

![image-20210402105104272](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402105104272.png)

coll2在执行拷贝算法之前，显式改变了空间的大小

coll3则在初始化时就制定了空间的大小

2、使用插入迭代器

插入迭代器使得算法的操作由覆写变成了插入，不再需要确保空间大小。

# 迭代器之适配器

![image-20210402105700807](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402105700807.png)



## Insert Iterator（安插型迭代器）

它可以使算法以安插而非覆写方式运作。使用它可以解决算法的“目标空间不足”问题，它会促使目标区间的大小按需要成长

![image-20210402105901123](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402105901123.png)

#### 三种插入迭代器

![image-20210402110024151](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402110024151.png)

![image-20210402110055530](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402110055530.png)

在关联容器和无序容器中也能使用一般插入迭代器。在这两个容器中，你所给的位置只是一个提示，帮助容器确定从什么地方开始查找正确的安插位置。容器有完全的自由决定要不要忽略它。

![image-20210402110305529](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402110305529.png)

#### 例子

![image-20210402110329292](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402110329292.png)

## Stream Iterator（串流迭代器）

Stream Iterator被用来读写Stream，它们提供了必要的抽象性，使得来自键盘的输入像是一个集合，你能够从中读取内容

### 用例及分析

![image-20210402110901138](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402110901138.png)

![image-20210402111006382](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402111006382.png)

![image-20210402111037472](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402111037472.png)

![image-20210402111107862](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402111107862.png)

## Reverse Iterator（反向迭代器）

反向迭代器会造成算法逆向操作，其内部将对递增操作符的调用转化为对递减操作符的调用。反之亦然

## Move Iterator（搬移迭代器）

![image-20210402111354898](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402111354898.png)

# 更易型算法（Manipulating Algorithm）

![image-20210402115542966](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402115542966.png)

![image-20210402115633130](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210402115633130.png)

## 移除元素（Removing）

算法remove（）自某个区间删除元素. 它将指定值的后一位覆盖到前一位上

![image-20210420094936569](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420094936569.png)

![image-20210420094944066](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420094944066.png)

该算法没有改变容器的大小，被删除元素会被它后一位的元素覆盖。在后面多出来的元素值则不确定。该算法返回一个迭代器，该迭代器指向删除元素后新容器的尾后迭代器位置。可以使用返回值取得的迭代器来缩小容器的大小，从而达到真正删除元素，并缩小容器大小的目的。

![image-20210420095414856](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420095414856.png)

![image-20210420095423723](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420095423723.png)

## 更易关联式和无序容器

更易型算法（remove、reorder、modify）不能用于关联式或无序容器。如果更改某位置上的值，对于关联式容器而言，这会破坏它原本排好的顺序；对无序容器而言，这会破坏其hash函数的结果。这些行为会导致编译错误。

# 以函数作为算法的实参

## 以函数作为算法的实参

### for_each算法

它针对区间内的每一个元素，调用一个由用户指定的函数

![image-20210420100506973](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420100506973.png)

### transform算法

指定一个源区间和一个目的地，将源区间的元素传入函数，并将取得的返回值放入目的地中

![image-20210420100732513](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420100732513.png)

## 判断式（predicate）

也就是所谓的谓词函数，它是一个bool型函数，通常通过它返回的布尔值来作为排序准则或查询准则

STL要求，针对相同的值，predicate必须得出相同的结果。所以那些“被调用时会改变自己内部状态”的函数就被排除在外。

### find_if

在区间中寻找第一个满足“传入之单参判断式”运算结果为true的第一个元素。如果区间内不存在该元素，则返回end

![image-20210420101301910](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420101301910.png)

# 使用lambda

使用lambda的好处：可以在调用lambda处就能直接浏览其意图，不需要像函数或者函数对象那样还要滑动屏幕去寻找定义。

方便性、可读性、快速性、可维护性

lambda的局限：当要使用判断式的类型，或者需要多次使用同一个判断式时，lambda就不太行了

# 函数对象

## 定义一个函数对象

只需要在类内定义operator()操作符，并给予合适的参数就行了

![image-20210420101827039](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420101827039.png)

函数对象有以下特点：

1、函数对象是一种带状态的函数：它拥有成员变量和成员函数，可以存储它的状态

2、每个函数对象有其自己的类型

3、函数对象通常比寻常函数速度快：就template概念而言，很多细节在编译期就已确定

当需要多次执行函数，并且每次执行函数用到的特定值不同时，就可以使用函数对象了

## 预定义的函数对象

### less<>

< 判断

### negate<>

取负操作

## Binder

使用特殊的函数适配器binder，将预定义的函数对象和其他数值结合为一体。

![image-20210420102940521](D:\学习笔记\learningNote\c++  标准程序库\《C++标准库》第6章 标准模板库\image-20210420102940521.png)

bind的第一个参数传入可调用对象，后面接着该可调用对象的参数。可以使用占位符指定调用该bind函数时传入参数对应的位置。

占位符需要使用命名空间 std::placeholders

# 函数对象 VS lambda

函数对象可以拥有内部状态，而lambda表达式则没有。

lambda表达式可以在调用处很直观的看出来它的意义，但如果一个lambda在许多地方被需要，那么它的优点就有一部分褪色了。

# 容器内的元素

## 容器元素的基本必要条件

1、元素必须可复制或可搬移。也就是说，元素类型必须隐式或显式**提供一个copy或move构造函数**。

2、元素必须可被赋值操作符加以搬移或赋值。容器和算法以新元素覆写旧元素时用的是**assignment操作符**

3、元素必须可被一个**析构函数**销毁。

## 针对不同容器应该满足的要求

1、对序列式容器而言，元素的默认构造函数必须可用。这样我们可以在不给予任何初值的情况下创建一个非空容器

2、对于某些操作，必须定义操作符==以执行相等测试。用来执行查找元素

3、在关联式容器中，元素必须定义出适用于排序准则的操作。默认情况下是操作符<，它将被函数对象less<>调用。

4、无需容器应该为元素提供一个hash函数，和一个等同时测试准则

## Value语义 vs Reference语义

通常，所有容器都会建立元素的拷贝，返回的也是元素的拷贝。这意味着容器内的元素与你放进去的东西相等但非同一。对容器元素的修改实际上改变的是拷贝而不是原件。

# STL内部的错误和异常

## 错误处理

STL设计宗旨是效能优先，安全次之。差错检测相当花时间，所以STL中几乎没有它的踪影。所以在使用STL时，我们必须遵守如下准则：

1、迭代器务必合法而有效：值得注意的是，某些更易型操作会导致迭代器失效

2、迭代器如果指向“逾尾（end）”位置，它并不指向任何对象，因此不能对它调用operator *或operator ->

3、区间必须是合法的：用来表示某区间的前后两迭代器必须指向同一容器，从第一个迭代器出发能够到达第二个迭代器的位置

4、如果涉及的区间不止一个，第二个区间及后续各区间必须拥有“至少和第一区间一样”的元素

5、覆写动作中的目标区间必须拥有足够元素，否则就必须采用插入型迭代器

## 异常处理

### 两个会抛出异常的函数

C++ standard只要求两个函数必要时直接引发异常：

at（）：它是下标操作符的受验版本，当下标不合法时会抛出异常

reserve（）：如果传入的元素个数超过max_size（），会抛出异常

### C++ STL针对异常做出的保证

1、一般而言，没有任何的erase（）、clear（）、pop_back（）、swap（）函数会抛出异常。也没有任何被返回的迭代器copy构造函数或assignment操作符会抛出异常

2、对于所有以结点为构造基础的容器（list、set、multiset、multimap、map、无序容器），如果结点构造失败，容器将保持不变。移除节点的动作保证不会失败。

3、关联式容器插入多个元素，插入元素的操作要么成功，要么就不产生任何效果。这是为了保证它的排序

4、对于list，除了remove、remove_if、merge、sort和unique之外，其它操作要么成功要么失败。所以当我们需要一个事务安全的容器时，可以考虑使用list

5、所有以array为基础构造的容器（array、vector、deque）。如果在安插元素时失败，则不能做到完全回滚。因为如果要达到完全回滚，则需要搬动大量的元素，这样效率极低，违背了STL的设计理念。

6、析构函数不得抛出异常

# 扩展STL

你可以提供自己的容器、迭代器、算法或函数对象，前提是它们必须满足某些条件：

1、凡是行为像是容器的东西，它就是个容器

2、凡是行为像迭代器的东西，它就是个迭代器

因此，每当你有一个“像容器”的class，你可以借由提供相应的接口（begin（）、end（）和若干类型定义等）

## 派生自STL Type

基于效率考虑，所有STL class都不带virtual函数，夜因此不在public继承中提供多态。



















